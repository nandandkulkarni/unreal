# Project Handoff: Unified Motion Planning System

## Objective
Establish a single source of truth for motion planning where `motion_planner.py` generates bit-perfect keyframes for both the Python Visualizer (Pygame) and Unreal Engine (Sequencer).

## What Worked & Verified
- [x] **Bit-Perfect Parity**: The Pygame visualizer now consumes the **exact same keyframes** that are sent to Unreal. No more drift between simulation and execution.
- [x] **Fluent API**: Chained commands like `.move().meters(100).target_speed(10)` are fully functional and translate to complex velocity ramps automatically.
- [x] **Velocity Ramps**: Smooth acceleration/deceleration is handled by the kinematic integrator in `motion_planner.py`.
- [x] **Environment Mocking**: The `unreal_mock.py` system successfully satisfies all `import unreal` calls in the shared planner, allowing local visualization without the Unreal Editor.
- [x] **Multi-Runner Execution**: The system handles simultaneous `move` commands for multiple actors (e.g., `Runner1` and `Runner2` sprinting in parallel).

## Where to Start Next
1.  **Final Unreal Verification**: 
    - The latest `ImportError` (circular dependency) was fixed by moving `debug_db` into a `diagnostics` package. 
    - **First Action**: Run `python movies/sprint_fluent.py` and verify that the Unreal Editor's `ThirdPerson.log` shows "SCENE GENERATION COMPLETE" and the Sequencer tracks are populated.
2.  **Generalizing Corridor Math**: 
    - The current `process_move` in `motion_planner.py` uses simplified lateral shifts for corridors.
    - **Goal**: Update the logic to use a full perpendicular vector (`fwd['y'], -fwd['x']`) so that corridor centering works even if the actor is facing a custom direction (e.g., diagonal or 90-degree turns).
3.  **Corridor Strafe Scenario**:
    - Verify `python run_visualizer.py sprint_turn`. The actor should "strafe" sideways while continuing to run forward as the corridor boundaries shift.

## Core Architecture: The "Playback" Model
The system is divided into three phases:
1.  **Planning Phase**: A "Movie" script (e.g., `sprint_fluent.py`) defines high-level commands.
2.  **Processing Phase**: `motion_planner.py` interprets these commands to calculate dense keyframes (Location/Rotation) at a specific FPS. It uses `unreal_mock.py` to simulate Unreal math outside the editor.
3.  **Playback Phase**:
    *   **Visualizer**: `simulation_engine.py` reads the planned keyframes and interpolates positions for the 2D display.
    *   **Unreal**: `run_scene.py` reads the same keyframes and applies them to a Sequencer track.

> [!IMPORTANT]
> This ensures that what you see in the visualizer is **exactly** what will happen in Unreal.

## How to Run

### 1. The 2D Visualizer
To see a movie in the Pygame visualizer:
```powershell
# Run a specific movie by name (without .py)
python run_visualizer.py sprint_fluent

# Run a specific JSON plan directly
python run_visualizer.py dist/sprint_fluent.json
```

### 2. The Unreal Engine Execution
To trigger a movie *inside* an open Unreal Editor instance (requires Remote Control Plugin):
```powershell
# Trigger a movie script
python trigger_movie.py movies/sprint_fluent.py

# Trigger a pre-exported JSON plan
python trigger_movie.py dist/sprint_fluent.json
```

### 3. One-Click Unified Run
The `MovieBuilder` now has a `.run()` method:
```python
# In your movie script:
movie.run(to_unreal=False) # Opens Visualizer
movie.run(to_unreal=True)  # Triggers Unreal
```

## The Fluent API (MotionBuilder)
Example of the new movement syntax:
```python
runner = movie.add_actor("Runner1", location=(0, 0, 0))
runner.move()\
    .meters(100)\
    .start_speed(0)\
    .target_speed(10)\
    .corridor(left=2.44, right=3.66)\
    .radius(0.35)
```

## Troubleshooting & Logs
- **Unreal Logs**: `C:\UnrealProjects\ThirdPerson\Saved\Logs\ThirdPerson.log`
- **Circular Imports**: If you see `ImportError: cannot import name 'debug_db'`, ensure you are importing from `motion_system.diagnostics.debug_db` or via the fixed `motion_system/__init__.py`.
- **Mock Issues**: If a new Unreal class is used in the planner, it must be added to `unreal_mock.py`.

## The Simulator (Visualizer)
The visualizer (`visualizer/main.py`) uses Pygame to render the 2D plane.
- **Coordinate System**: It converts Unreal centimeters (cm) to meters (m) for display.
- **SimEngine**: `visualizer/simulation_engine.py` is the playback core. It doesn't calculate physics anymore; it simply looks up the `calculated_keyframes` list generated by `MotionPlanner`.
- **Interpolation**: It uses linear interpolation between keyframes if the simulation FPS differs from the plan FPS (though they usually match at 30).

## Current Work-in-Progress
- **Lateral Turn Logic**: I've implemented a strafe-style corridor shift in `process_move`. The next step is to make this generic so actors can turn 90 degrees and the corridor boundaries follow the new local forward/right vectors correctly.
- **Unreal verification**: The `trigger_movie.py` bridge is currently returning `False` in some runs due to a circular import in `motion_system/__init__.py`. I've applied a fix by separating the diagnostics package, but this needs final verification in the Unreal console.

## Files Reference
- `motion_builder.py`: Fluent API implementation.
- `motion_planner.py`: Kinematics, ramps, and corridor logic.
- `unreal_mock.py`: Structural mocks for Unreal API.
- `visualizer/simulation_engine.py`: Playback logic for the visualizer.
- `trigger_movie.py`: Bridge to Unreal Remote Control.
- `run_scene.py`: Internal Unreal runner (applied via remote control).
